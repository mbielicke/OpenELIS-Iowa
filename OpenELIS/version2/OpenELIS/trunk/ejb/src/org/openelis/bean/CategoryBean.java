package org.openelis.bean;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import javax.annotation.Resource;
import javax.annotation.security.RolesAllowed;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.naming.InitialContext;
import javax.persistence.EntityManager;
import javax.persistence.FlushModeType;
import javax.persistence.NoResultException;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;

import org.jboss.annotation.security.SecurityDomain;
import org.openelis.domain.CategoryDO;
import org.openelis.domain.DictionaryDO;
import org.openelis.entity.Category;
import org.openelis.entity.Dictionary;
import org.openelis.gwt.common.FieldErrorException;
import org.openelis.gwt.common.LastPageException;
import org.openelis.gwt.common.RPCException;
import org.openelis.gwt.common.TableFieldErrorException;
import org.openelis.local.LockLocal;
import org.openelis.meta.CategoryMeta;
import org.openelis.meta.DictionaryMeta;
import org.openelis.meta.DictionaryRelatedEntryMeta;
import org.openelis.remote.CategoryRemote;
import org.openelis.util.Meta;
import org.openelis.util.QueryBuilder;
import org.openelis.utils.GetPage;

import edu.uiowa.uhl.security.domain.SystemUserDO;
import edu.uiowa.uhl.security.local.SystemUserUtilLocal;

@Stateless
@SecurityDomain("openelis")
@RolesAllowed("dictionary-select")
public class CategoryBean implements CategoryRemote {
    
    @PersistenceContext(name = "openelis")
    private EntityManager manager;

    
    @EJB
    private SystemUserUtilLocal sysUser;
    
    @Resource
    private SessionContext ctx;
    
    private LockLocal lockBean;
    
    {
        try {
            InitialContext cont = new InitialContext();
            lockBean =  (LockLocal)cont.lookup("openelis/LockBean/local");
        }catch(Exception e){
            e.printStackTrace();
        }
    }
   
    public CategoryDO getCategory(Integer categoryId) {        
        
        Query query = manager.createNamedQuery("getCategory");
        query.setParameter("id", categoryId);
        CategoryDO category = (CategoryDO) query.getSingleResult();// getting category with address and contacts

        return category;
    }

 

    public Integer getSystemUserId() {
        try {
            SystemUserDO systemUserDO = sysUser.getSystemUser(ctx.getCallerPrincipal()
                                                                 .getName());
            return systemUserDO.getId();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
        }
        
    }

    public List query(HashMap fields, int first, int max) throws Exception {
        StringBuffer sb = new StringBuffer();
        QueryBuilder qb = new QueryBuilder();        
        
        //the meta objects which contain the names of the entities and aliases for various fields in the query(in EJBQL)
        //that will be eventually generated by the query builder class 
        CategoryMeta categoryMeta = CategoryMeta.getInstance();
        DictionaryMeta dictionaryMeta = DictionaryMeta.getInstance();
        DictionaryRelatedEntryMeta dicRelatedEntryMeta = DictionaryRelatedEntryMeta.getInstance();
        
        //this is done so that the query builder will be aware of the names of the entities and the various aliases
        qb.addMeta(new Meta[]{categoryMeta, dictionaryMeta, dicRelatedEntryMeta});
        
        //setting the select clause
        qb.setSelect("distinct "+CategoryMeta.ID+", "+CategoryMeta.NAME);
        
        // adding the alias for the category entity
        qb.addTable(categoryMeta);
        
        //this method is going to throw an exception if a column doesnt match
        qb.addWhere(fields);      

        // setting the order by clause
        qb.setOrderBy(CategoryMeta.NAME);
        
        // this is done to make sure that if the generated query contains alias for related entry join attribute(as specified in 
        // the entity class) then the alias for the entry for which this related entry is specified is present, otherwise the query will produce 
        // an exception on the lines of "xyz field/alias not found"
        if(qb.hasTable(dicRelatedEntryMeta.getTable()))
        	qb.addTable(dictionaryMeta);
        
        // this is done such that a string representation of the generated query can be obtained   
        sb.append(qb.getEJBQL());
        
        // create a query object from the string representation of the generated query
        Query query = manager.createQuery(sb.toString());
       
        // done to make sure that only the results for the current page of data are returned
        if(first > -1 && max > -1)
       	 query.setMaxResults(first+max);
        
//      ***set the parameters in the query
        qb.setQueryParams(query);
        
        //getting the results for the current page of data
        List returnList = GetPage.getPage(query.getResultList(), first, max);
        if(returnList == null)
       	 throw new LastPageException();
        else
       	 return returnList;        
            
    }

    @RolesAllowed("dictionary-update")
    public Integer updateCategory(CategoryDO categoryDO, List dictEntries)throws Exception {
        Category category  = null;
       try{ 
        manager.setFlushMode(FlushModeType.COMMIT);
        Query query = manager.createNamedQuery("getTableId");
        query.setParameter("name", "category");
        Integer categoryReferenceId = (Integer)query.getSingleResult();                
        
        //validate the category before adding or updating it
        List<Exception> exceptionList = new ArrayList<Exception>();
        validateCategory(categoryDO,exceptionList);  
        if(exceptionList.size() > 0){
            throw (RPCException)exceptionList.get(0);
        }                             
                                                 
        ArrayList<DictionaryDO> updateList = null;
        ArrayList<DictionaryDO> deleteList = null;
        int index =0;
         ArrayList<String> systemNames = new ArrayList<String>();
        
        ArrayList<String> entries = new ArrayList<String>();
        for (Iterator iter = dictEntries.iterator(); iter.hasNext();) {
            DictionaryDO dictDO = (DictionaryDO)iter.next();
            
            exceptionList = new ArrayList<Exception>();
            
            // validate every DO before adding it to the update or delete lists             
             validateDictionary(dictDO, categoryDO.getId(),index,systemNames,entries,exceptionList);
             if(exceptionList.size() > 0){
                 throw (RPCException)exceptionList.get(0);
             }                                     
             
             boolean update = false;
             //check to  see if the data specified in this DO is to be removed from the database              
               if(new Boolean(true).equals(dictDO.getDelete())){
                   if(deleteList==null){
                       deleteList = new ArrayList<DictionaryDO>();                       
                   }
                   //if the data in is to be removed, add the DO to delete list                   
                   deleteList.add(dictDO);
               }else{
                   // else mark it to be added to the update list
                   update = true;
               }
              
             
                         
             if(update){
                 if(updateList ==null){
                     updateList = new ArrayList<DictionaryDO>();
                 }
                 updateList.add(dictDO);                                 
             }
            index++; 
        }
        
        if (categoryDO.getId() == null){
            category = new Category();
        } 
        else{
            category = manager.find(Category.class, categoryDO.getId());
        }
        
        // add or update category as specified by the DO's values 
        category.setDescription(categoryDO.getDescription());                       
        category.setSystemName(categoryDO.getSystemName());
        category.setName(categoryDO.getName());
        category.setSection(categoryDO.getSection());
        
        if(category.getId()==null){
            manager.persist(category);
        }
        
        // add or update  dictionary entities as specified in the DO
       if(updateList!=null){ 
        for(int iter = 0; iter < updateList.size();iter++){
            Dictionary dictionary = null;
            DictionaryDO dictDO = updateList.get(iter); 
            if(dictDO.getId() == null){
                dictionary = new Dictionary();
            }else{
                 dictionary  = manager.find(Dictionary.class,dictDO.getId());
           }
            dictionary.setCategory(category.getId());
            dictionary.setEntry(dictDO.getEntry());
            dictionary.setIsActive(dictDO.getIsActive());
            dictionary.setLocalAbbrev(dictDO.getLocalAbbrev());
            dictionary.setRelatedEntryId(dictDO.getRelatedEntryId());                 
            dictionary.setSystemName(dictDO.getSystemName());    
                                     
         if(dictionary.getId()==null){                  
           manager.persist(dictionary);
         }
        }
       }  
       
      // delete dictionary entities as specified by the DO's values
      if(deleteList!=null){  
       for(int iter = 0; iter < deleteList.size(); iter++){
           Dictionary dictionary = null;
           DictionaryDO dictDO = deleteList.get(iter); 
           
           if (dictDO.getId() != null){
               dictionary  = manager.find(Dictionary.class,dictDO.getId());
               //delete the dictionary row from the database                      
                  manager.remove(dictionary);     
          }    
       } 
      }  
        lockBean.giveUpLock(categoryReferenceId,category.getId()); 
        
       }catch(Exception ex){ 
           ex.printStackTrace();
           throw ex;        
       }
        return  category.getId();
    }

    public List getDictionaryEntries(Integer categoryId) {
        Query query = manager.createNamedQuery("getDictionaryEntries");
        query.setParameter("id", categoryId);
        
        List providerAddresses = query.getResultList();// getting list of dictionary entries  
    
        return providerAddresses;
    }
    
    public List getDropdownValues(Integer categoryId) {
    	Query query = manager.createNamedQuery("getDictionaryDropdownValues");
    	query.setParameter("id", categoryId);
    	
    	return query.getResultList();
    }
    
    public List getMatchingEntries(String entry, int maxResults){
       Query query = manager.createNamedQuery("getMatchingEntries");  
       query.setParameter("entry", entry);       
       query.setMaxResults(maxResults);       
       
       List entryList = null;
       try{ 
           entryList = (List)query.getResultList();
       }catch(Exception ex){
           ex.printStackTrace();
          
       }     
       return entryList;
    }

    /** This function is used to find the id for the dictionary record that has its system name set to the one
     * specified by the parameter "systemname".
     * @return The id of the record if there is such a dictionary record in the database or null if there isn't  
     */     
    public Integer getEntryIdForSystemName(String systemName)throws Exception{ 
        Query query = manager.createNamedQuery("getEntryIdForSystemName");  
        query.setParameter("systemName", systemName);
        Integer entryId = null;
        try{ 
          // this code will throw an exception if the query created above did not return any result 
          // or it will return as a result the id of the sought record           
          entryId = (Integer)query.getSingleResult();
        }catch(NoResultException ex){
            // if no results returned by the execution of the query, return null
            return null;
        } catch(Exception ex){
            ex.printStackTrace();
            throw ex;
        }    
        return entryId;
    } 
    
    /** This function is used to find the id for the dictionary record that has its entry text set to the one
     * specified by the parameter "entry".
     * @return The id of the row if there is such a dictionary record in the database or null if there isn't  
     */ 
    public Integer getEntryIdForEntry(String entry)throws Exception{
        Query query = manager.createNamedQuery("getEntryIdForEntry");  
        query.setParameter("entry", entry);
        Integer entryId = null;
        try{ 
            //this code will throw an exception if the query created above did not return any result 
            // or it will return as a result the id of the sought record  
          entryId = (Integer)query.getSingleResult();
        }catch(NoResultException ex){
           //if no results returned by the execution of the query, return null
            return null;
        } catch(Exception ex){
            ex.printStackTrace();
            throw ex;
        }     
        return entryId;
    } 
        
    /** This function is used to find the id for the category record that has its entry text set to the one
     * specified by the parameter "systemName".
     * @return The id of the row if there is such a category record in the database or null if there isn't  
     */ 
    public Integer getCategoryId(String systemName){
        Query query = manager.createNamedQuery("getCategoryIdBySystemName");  
        query.setParameter("systemName", systemName);
        Integer categoryId = null;
        try{ 
            // this code will throw an exception if the query created above did not return any result 
            // or it will return as a result the id of the sought record  
            categoryId = (Integer)query.getSingleResult();        
        } catch(Exception ex){          
            ex.printStackTrace();
            
        }   
        return categoryId;
    }
    
   /** This function is used to find the entry text for the dictionary record the id for which
    *  is specified by the parameter "id"
    *  @return  An array of objects containing the id and the entry text of the record 
    *  if there is such a dictionary record in the database or null if there isn't  
    */
    public Object[] autoCompleteLookupById(Integer id)throws Exception{
      try{  
        Query query  = manager.createNamedQuery("getEntryAutoCompleteById");
        query.setParameter("id",id);
        //this code will throw an exception if the query created above did not return any result 
        // or it will return as a result an array of objects containing the id and the entry text
        // of the sought record    
        return (Object[])query.getSingleResult();
      }catch(NoResultException ex){
         //if no results returned by the execution of the query, return null
          return null;
      } catch(Exception ex){
          throw ex;
      }
      
    }
    
    /** This function is used to return a CategoryDO object and create a lock for the category record specified by the
     *  parameter "categoryId".This will disallow any updates to this record until and unless the user which made this lock to be created, 
     *  either commits or aborts the current transaction i.e. getCategoryAndUnlock(Integer categoryId) is called.    
     *  @return  A CategoryDO object containing the data for the category record specified by the parameter "categoryId"
     *  @see getCategoryAndUnlock(Integer)
     */
    @RolesAllowed("dictionary-update")
    public CategoryDO getCategoryAndLock(Integer categoryId)throws Exception {
        Query query = manager.createNamedQuery("getTableId");
        query.setParameter("name", "category");
        //this line will create the lock
        lockBean.getLock((Integer)query.getSingleResult(),categoryId);
        
        return getCategory(categoryId);
    }

    /** This function is used to return a CategoryDO object and release any locks for the category record specified by the parameter "categoryId".     
     *  @return  A CategoryDO object containing the data for the category record specified by the parameter "categoryId"
     *  @see getCategoryAndLock(Integer)
     */
    public CategoryDO getCategoryAndUnlock(Integer categoryId) {
        
        Query unlockQuery = manager.createNamedQuery("getTableId");
        unlockQuery.setParameter("name", "category");
       //this line will release the lock
        lockBean.giveUpLock((Integer)unlockQuery.getSingleResult(),categoryId);
        
        return getCategory(categoryId);
    } 
    
    
    /** This function validates the data in CategoryDO specified by the parameter "categoryDO" before it can be committed to the database. 
     *  It is called before any update is attempted so that if data is invalid, the user can be
     *  notified.It is also called during an update. The parameter "exceptionList" is the list of exceptions that could potentially
     *  be thrown due to the invalidity of data due to certain reasons. This list is ultimately used to notify users about violation of 
     *  some constraint related to specific fields on the screen.
     *  @see validateDictionary(DictionaryDO, Integer, int ,List,List,List) 
     */
    private void validateCategory(CategoryDO categoryDO,List<Exception> exceptionList){
        // this code will check whether the system name, if specified, for this DO is not used for any other category record
        // i.e. for a record whose Id is not the same as the Id specified for this DO
            if(!("").equals(categoryDO.getSystemName())){
                Query catIdQuery  = manager.createNamedQuery("getCategoryIdForCatSysName");
                catIdQuery.setParameter("systemName", categoryDO.getSystemName());
                Integer catId = null;
                try{
                    // this will be the Id of the record where value for system name is the one specified by the DO
                    // if there is no such record then NoResultException will be thrown
                    catId = (Integer)catIdQuery.getSingleResult();
                }catch(NoResultException ex){                     
                    ex.printStackTrace();
                }catch(Exception ex){
                    exceptionList.add(ex);
                }
                
              if(catId!=null){
                // if the Id for this DO is null, then it will mean that this is a new record and thus if the above query returned
                // a result then this is the violation of the uniqueness constraint described above because an attempt has been made to use
                //  an already used system name for a new record
                // if the id for this DO is not null and the id for the system name specified for it is not same as the id specifed for the DO,
                //  then  again the violation of the uniqueness constraint, in both cases a exception added to the list of exceptions  
                if(!catId.equals(categoryDO.getId())){
                    exceptionList.add(new FieldErrorException("fieldUniqueException",CategoryMeta.SYSTEM_NAME));
                }  
              }                                 

       }else {
           // system name is required to be specified for a category
           exceptionList.add(new FieldErrorException("fieldRequiredException",CategoryMeta.SYSTEM_NAME)); 
       } 
            
         if(("").equals(categoryDO.getName())){      
             // name is required to be specified for a category
                exceptionList.add(new FieldErrorException("fieldRequiredException",CategoryMeta.NAME)); 
            }
            
    }
    
    /** This function validates the data in DictionaryDO specified by the parameter "dictDO" before it can be committed to the database. 
     *  It is called before any update is attempted so that if data is invalid, the user can be
     *  notified.It is also called during an update. The parameter "exceptionList" is the list of exceptions that could potentially
     *  be thrown due to the invalidity of data due to certain reasons. This list is ultimately used to notify users about violation of 
     *  some constraint related to specific fields on the screen.
     *  The parameter "categoryId" is the id of the category to which this dictionary record belongs.
     *  The lists "systemNames" and "entries" are the lists of values for all DictionaryDOs  validated so far.  
     *  The parameter "index" is the index in the list of DictionaryDOs required for a given update attempt 
     *  The parameter "exceptionList" is the list of exceptions that could potentially
     *  be thrown due to the invalidity of data due to certain reasons.
     *  @see validateCategory(CategoryDO, List) 
     */
    private void validateDictionary(DictionaryDO dictDO, Integer categoryId, int index,List<String>systemNames,List<String>entries,List<Exception> exceptionList){             
             
            if(!("").equals(dictDO.getEntry())){   
             if(!entries.contains(dictDO.getEntry())){
               entries.add(dictDO.getEntry());
              }else{        
                  // entry texts only have to be unique for a category and not across all the categories  
                  exceptionList.add(new TableFieldErrorException("fieldUniqueOnlyException", index,DictionaryMeta.ENTRY));
              } 
            }else{              
                // entry texts must be specified for each row in the dictionary table 
                exceptionList.add(new TableFieldErrorException("fieldRequiredException", index,DictionaryMeta.ENTRY));
            }              
           
            
             if(!("").equals(dictDO.getSystemName())){ 
               if(!systemNames.contains(dictDO.getSystemName())){     
                 Query catIdQuery  = manager.createNamedQuery("getCategoryIdForDictSysName");
                 catIdQuery.setParameter("systemName", dictDO.getSystemName());
                 Integer catId = null;
                 try{
                     //checking to see if there is another dictionary for which this system name has been used and which 
                     //belongs to some other category
                     catId = (Integer)catIdQuery.getSingleResult();
                 }catch(NoResultException ex){                     
                     ex.printStackTrace();
                 }catch(Exception ex){                    
                     exceptionList.add(ex);
                 }
                 
                  if(catId != null){
                      if(!catId.equals(categoryId)){                                                        
                        //system names have to be unique across all the categories  
                          exceptionList.add(new TableFieldErrorException("fieldUniqueException", index,DictionaryMeta.SYSTEM_NAME));
                      }
                  }
                           
                systemNames.add(dictDO.getSystemName());                            
            }else{      
              // system names have to be unique for a category
                exceptionList.add(new TableFieldErrorException("fieldUniqueOnlyException", index,DictionaryMeta.SYSTEM_NAME));
            }
            
       }                 
    }
    
    /** This function is called to validate data when new records are being added to the database  
     *  The parameter "categoryDO" contains the data for a category record.
     *  The parameter "dictDOList" is the list of DictionaryDOs that represent all the records that 
     *  belong to the one specified by "categoryDO"   
     *  validateForAdd(CategoryDO, List)
     */
    public List validateForAdd(CategoryDO categoryDO, List<DictionaryDO> dictDOList){
        // this is the list of all the exceptions that will potentially be caused by the violation of one or more constraints duing validation
        List<Exception> exceptionList = new ArrayList<Exception>();
        
        // first validate the data for the category 
        validateCategory(categoryDO,exceptionList);        
        ArrayList<String> systemNames = new ArrayList<String>();
        
        ArrayList<String> entries = new ArrayList<String>();
        // then validate the data for all the dictionary records 
        for (int iter =0; iter< dictDOList.size(); iter++) {
            DictionaryDO dictDO = (DictionaryDO)dictDOList.get(iter);
            validateDictionary(dictDO,categoryDO.getId(),iter,systemNames,entries,exceptionList);            
        }
        
        return exceptionList;
    }
    
    /** This function is called to validate data when an existing category record is being updated in the database  
     *  The parameter "categoryDO" contains the data for a category record.
     *  The parameter "dictDOList" is the list of DictionaryDOs that represent all the records that belong to the one 
     *  specified by "categoryDO"   
     *  @see validateForAdd(CategoryDO, List)
     */
    public List validateForUpdate(CategoryDO categoryDO, List<DictionaryDO> dictDOList){
      // this is the list of all the exceptions that will potentially be caused by 
      //  the violation of one or more constraints duing validation
        List<Exception> exceptionList = new ArrayList<Exception>();
        
        // first validate the data for the category 
        validateCategory(categoryDO,exceptionList);        
        ArrayList<String> systemNames = new ArrayList<String>();
        
        ArrayList<String> entries = new ArrayList<String>();
        // then validate the data for all the dictionary records 
        for (int iter =0; iter< dictDOList.size(); iter++) {
            DictionaryDO dictDO = (DictionaryDO)dictDOList.get(iter);
            validateDictionary(dictDO,categoryDO.getId(),iter,systemNames,entries,exceptionList);            
        }
        
        return exceptionList;
    }
}
